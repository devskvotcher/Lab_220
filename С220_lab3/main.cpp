//Лабораторная работа №3
////initializer_list, move, default, delete, move итераторы
//Задание.Разработайте класс, который реализует функциональность очереди с элементами любого типа.
//Данные требуется хранить в динамическом массиве, при этом использовать массив как циклический буфер.Пояснение: так как очередь – это специфическая структура данных, для которой новые данные помещаются в конец, а  «старые» данные изымаются из начала очереди = > если последний элемент массива задействован, то начало скорее всего уже освободилось = > «закольцовываем» буфер, продолжая заполнять с нулевого элемента.
//Несмотря на указанную специфичность такой структуры данных, могут возникать ситуации, когда пользователь вызвал push(), а свободных элементов в очереди не осталось = > при необходимости массив следует «расширять».
//При реализации нужно обеспечить эффективную работу с динамической памятью = >
//•	предусмотреть наличие резервных элементов
//•	память без очевидной необходимости не перераспределять
//Внимание!
//1.	Очередь реализуем без использования «сырой памяти»!А эффективность достигаем за счет использования move - семантики
//2.	Очередь выводим на печать с помощью range - base - for
//Тестируем разработанный класс на приведенном ниже фрагменте.Замечание: если Вы не учились на предыдущих курсах и не разрабатывали используемый в примере класс MyString, просто замените его на std::string
//
//Следующий фрагмент должен работать не только корректно, но и эффективно :
//
//MyQueue<MyString>  q1{ MyString(“AAA”), MyString(“qwerty”),<другие_инициализаторы> };
//
////использование MyQueue в диапазонном for:v
//for (const auto& el : q1) { std::cout << el << ' '; }
//
//MyString s(“abc”);
//q1.push(s);
//q1.push(MyString(“123”));
//MyString s1 = q1.pop();
//q1.push(“qqq”);
//MyQueue < MyString >  q2 = q1;
//MyQueue < MyString >  q22 = std::move(q1);
//
//MyQueue < MyString >  q3{ 10, MyString(“!”) }; //очередь должна содержать 10 элементов со строкой «!» 
//q1 = q3;
//q2 = MyQueue < MyString >(5, MyString(“ ? ”));
//q1 = { MyString(“bbb”), MyString(“ssss”) };
//
//
#define _CRT_SECURE_NO_WARNINGS
#include "MyQueue.h"
#include "MyString.h"
#include <iostream>
int main()
{
	MyQueue<MyString>  q1{ MyString("AAA"), MyString("qwerty"), MyString("qwerwdqwdty"), MyString("davhvoe") };
	//использование MyQueue в диапазонном for:
	for (const auto& el : q1) 
	{ 
		std::cout << el << ' '; 
	}
	std::cout << std::endl;
	_asm nop
	MyString s("abc");
	q1.push(s);
	q1.push(MyString("123"));
	std::cout << s << std::endl;
	for (const auto& el : q1)
	{
		int i = 0;
		std::cout << el << ' ';		
	}
	std::cout << std::endl;
	_asm nop
	MyString s1 = q1.pop();
	std::cout << s1 << std::endl;
	_asm nop
	q1.push("qqq");
	for (const auto& el : q1)
	{
		int i = 0;
		std::cout << el << ' ';
	}
	std::cout << std::endl;
	_asm nop
	MyQueue <MyString>  q2 = q1; 
	for (const auto& el : q2)
	{
		int i = 0;
		std::cout << el << ' ';
	}
	std::cout << std::endl;
	_asm nop
	MyQueue <MyString>  q22 = std::move(q1);
	for (const auto& el : q22)
	{
		int i = 0;
		std::cout << el << ' ';
	}
	std::cout << std::endl;
	_asm nop
	MyQueue <MyString>  q3{ 10, MyString("!") }; //очередь должна содержать 10 элементов со строкой «!» 
	for (const auto& el : q3)
	{
		int i = 0;
		std::cout << el << ' ';
	}
	std::cout << std::endl;
	_asm nop
	q1 = q3;
	for (const auto& el : q1)
	{
		std::cout << el << ' ';
	}
	std::cout << std::endl;
	_asm nop
	q2 = MyQueue < MyString >(5, MyString("?"));
	for (const auto& el : q2)
	{
		int i = 0;
		std::cout << el << ' ';
	}
	std::cout << std::endl;
	_asm nop
	q1 = { MyString("bbb"), MyString("ssss") };
	for (const auto& el : q1)
	{
		int i = 0;
		std::cout << el << ' ';
	}
	std::cout << std::endl;
	_asm nop
	//Где-то в итераторе принемать capacity, оператор разыменования должен пересчитывать
	return 0;
}